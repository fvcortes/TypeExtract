
@inproceedings{takikawa_is_2016,
	location = {New York, {NY}, {USA}},
	title = {Is Sound Gradual Typing Dead?},
	isbn = {978-1-4503-3549-2},
	url = {https://doi.org/10.1145/2837614.2837630},
	doi = {10.1145/2837614.2837630},
	series = {{POPL} '16},
	abstract = {Programmers have come to embrace dynamically-typed languages for prototyping and delivering large and complex systems. When it comes to maintaining and evolving these systems, the lack of explicit static typing becomes a bottleneck. In response, researchers have explored the idea of gradually-typed programming languages which allow the incremental addition of type annotations to software written in one of these untyped languages. Some of these new, hybrid languages insert run-time checks at the boundary between typed and untyped code to establish type soundness for the overall system. With sound gradual typing, programmers can rely on the language implementation to provide meaningful error messages when type invariants are violated. While most research on sound gradual typing remains theoretical, the few emerging implementations suffer from performance overheads due to these checks. None of the publications on this topic comes with a comprehensive performance evaluation. Worse, a few report disastrous numbers. In response, this paper proposes a method for evaluating the performance of gradually-typed programming languages. The method hinges on exploring the space of partial conversions from untyped to typed. For each benchmark, the performance of the different versions is reported in a synthetic metric that associates runtime overhead to conversion effort. The paper reports on the results of applying the method to Typed Racket, a mature implementation of sound gradual typing, using a suite of real-world programs of various sizes and complexities. Based on these results the paper concludes that, given the current state of implementation technologies, sound gradual typing faces significant challenges. Conversely, it raises the question of how implementations could reduce the overheads associated with soundness and how tools could be used to steer programmers clear from pathological cases.},
	pages = {456--468},
	booktitle = {Proceedings of the 43rd Annual {ACM} {SIGPLAN}-{SIGACT} Symposium on Principles of Programming Languages},
	publisher = {Association for Computing Machinery},
	author = {Takikawa, Asumu and Feltey, Daniel and Greenman, Ben and New, Max S. and Vitek, Jan and Felleisen, Matthias},
	date = {2016},
	note = {event-place: St. Petersburg, {FL}, {USA}},
	keywords = {Gradual typing, performance evaluation},
	file = {Full Text:/home/fcortes/Zotero/storage/CYADGLQE/Takikawa et al. - 2016 - Is Sound Gradual Typing Dead.pdf:application/pdf},
}

@article{gualandi_pallene_2020,
	title = {Pallene: A companion language for Lua},
	volume = {189},
	issn = {01676423},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S0167642320300046},
	doi = {10.1016/j.scico.2020.102393},
	shorttitle = {Pallene},
	pages = {102393},
	journaltitle = {Science of Computer Programming},
	shortjournal = {Science of Computer Programming},
	author = {Gualandi, Hugo Musso and Ierusalimschy, Roberto},
	urldate = {2022-11-27},
	date = {2020-04},
	langid = {english},
}

@book{ierusalimschy_programming_2016,
	location = {Rio de Janeiro},
	edition = {Fourth edition},
	title = {Programming in Lua},
	isbn = {978-85-903798-6-7},
	pagetotal = {369},
	publisher = {Lua.org},
	author = {Ierusalimschy, Roberto},
	date = {2016},
} 

  
@inproceedings{murbach_typed_2014,
author = {Maidl, Andr\'{e} Murbach and Mascarenhas, Fabio and Ierusalimschy, Roberto},
title = {Typed Lua: An Optional Type System for Lua},
year = {2014},
isbn = {9781450329163},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2617548.2617553},
doi = {10.1145/2617548.2617553},
abstract = {Dynamically typed languages trade flexibility and ease of use for safety, while statically typed languages prioritize the early detection of bugs, and provide a better framework for structure large programs. The idea of optional typing is to combine the two approaches in the same language: the programmer can begin development with dynamic types, and migrate to static types as the program matures. The challenge is designing a type system that feels natural to the programmer that is used to programming in a dynamic language.This paper presents the initial design of Typed Lua, an optionally-typed extension of the Lua scripting language. Lua is an imperative scripting language with first class functions and lightweight metaprogramming mechanisms. The design of Typed Lua's type system has a novel combination of features that preserves some of the idioms that Lua programmers are used to, while bringing static type safety to them. We show how the major features of the type system type these idioms with some examples, and discuss some of the design issues we faced.},
booktitle = {Proceedings of the Workshop on Dynamic Languages and Applications},
pages = {1â€“10},
numpages = {10},
keywords = {type systems, optional typing, Lua programming language, gradual typing},
location = {Edinburgh, United Kingdom},
series = {Dyla'14}
}
